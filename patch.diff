From 7455f6e043154a36f2b55c4ad51d51e4fdaa0331 Mon Sep 17 00:00:00 2001
From: Pierre Jay <p.jay@orius.co>
Date: Sun, 21 Sep 2025 12:49:15 +0200
Subject: [PATCH] Implement multi-interface support in ModbusServer

---
 src/apps/ModbusServer.cpp | 79 ++++++++++++++++++++++++++++-----------
 src/apps/ModbusServer.h   | 36 +++++++++++++++---
 2 files changed, 88 insertions(+), 27 deletions(-)

diff --git a/src/apps/ModbusServer.cpp b/src/apps/ModbusServer.cpp
index 7411ded..252db1c 100644
--- a/src/apps/ModbusServer.cpp
+++ b/src/apps/ModbusServer.cpp
@@ -11,9 +11,24 @@ namespace Modbus {
 // PUBLIC METHODS
 // ===================================================================================
 
-// Constructor with WordStore (now mandatory)
+// Constructor with single interface (backward compatible)
 Server::Server(ModbusInterface::IInterface& interface, IWordStore& store, uint8_t slaveId, bool rejectUndefined)
-    : _interface(interface), _serverId(slaveId), _rejectUndefined(rejectUndefined), _wordStore(store) {
+    : _serverId(slaveId), _rejectUndefined(rejectUndefined), _wordStore(store) {
+    _interfaces.fill(nullptr);
+    _interfaces[0] = &interface;
+    _interfaceCount = 1;
+    _isInitialized = false;
+}
+
+// Constructor with multiple interfaces (new)
+Server::Server(std::initializer_list<ModbusInterface::IInterface*> interfaces, IWordStore& store, uint8_t slaveId, bool rejectUndefined)
+    : _serverId(slaveId), _rejectUndefined(rejectUndefined), _wordStore(store) {
+    _interfaces.fill(nullptr);
+    _interfaceCount = 0;
+    for (auto* iface : interfaces) {
+        if (_interfaceCount >= MAX_INTERFACES) break;
+        _interfaces[_interfaceCount++] = iface;
+    }
     _isInitialized = false;
 }
 
@@ -28,22 +43,44 @@ Server::~Server() {
 Server::Result Server::begin() {
     if (_isInitialized) return Success();
 
-    if (_interface.getRole() != Modbus::SERVER) {
-        return Error(Server::ERR_INIT_FAILED, "interface must be SERVER");
-    }
+    // Initialize all interfaces with proper context routing
+    for (size_t i = 0; i < _interfaceCount; i++) {
+        if (_interfaces[i]->getRole() != Modbus::SERVER) {
+            return Error(Server::ERR_INIT_FAILED, "interface must be SERVER");
+        }
 
-    if (_interface.begin() != ModbusInterface::IInterface::SUCCESS) {
-        return Error(Server::ERR_INIT_FAILED, "interface init failed");
-    }
+        if (_interfaces[i]->begin() != ModbusInterface::IInterface::SUCCESS) {
+            return Error(Server::ERR_INIT_FAILED, "interface init failed");
+        }
 
-    auto rcvCb = [](const Modbus::Frame& frame, void* ctx) {
-        Modbus::Debug::LOG_MSG("Received request from interface");
-        static_cast<Server*>(ctx)->handleRequest(frame);
-    };
+        // Set up context for proper interface routing
+        _rcvCbContexts[i] = {this, _interfaces[i]};
 
-    auto setRcvCbRes = _interface.setRcvCallback(rcvCb, this);
-    if (setRcvCbRes != ModbusInterface::IInterface::SUCCESS) {
-        return Error(Server::ERR_INIT_FAILED, "cannot set receive callback on interface");
+        // Secure callback with interface identification
+        auto rcvCb = [](const Modbus::Frame& frame, void* ctx) {
+            // Defensive programming: validate context
+            if (!ctx) {
+                Modbus::Debug::LOG_MSG("ERROR: null context in receive callback");
+                return;
+            }
+
+            auto* callbackCtx = static_cast<RcvCallbackCtx*>(ctx);
+
+            // Validate context structure
+            if (!callbackCtx->server || !callbackCtx->sourceInterface) {
+                Modbus::Debug::LOG_MSG("ERROR: invalid context in receive callback");
+                return;
+            }
+
+            Modbus::Debug::LOG_MSG("Received request from interface");
+            // Route to handleRequest with proper source interface
+            callbackCtx->server->handleRequest(frame, *callbackCtx->sourceInterface);
+        };
+
+        auto setRcvCbRes = _interfaces[i]->setRcvCallback(rcvCb, &_rcvCbContexts[i]);
+        if (setRcvCbRes != ModbusInterface::IInterface::SUCCESS) {
+            return Error(Server::ERR_INIT_FAILED, "cannot set receive callback on interface");
+        }
     }
 
     // Sort WordStore for efficient lookups and validate overlaps
@@ -94,7 +131,7 @@ bool Server::isBusy() {
  * @param request The request to process
  * @return The result of the request
  */
-Server::Result Server::handleRequest(const Modbus::Frame& request) {
+Server::Result Server::handleRequest(const Modbus::Frame& request, ModbusInterface::IInterface& sourceInterface) {
     bool dropResponse = false;
 
     // Process request and send response atomically (request + response buffer + WordStore protected)
@@ -108,7 +145,7 @@ Server::Result Server::handleRequest(const Modbus::Frame& request) {
 
     // Ignore the Slave ID if the request is sent to a broadcast slave ID
     // or if the server is configured to catch all requests (broadcast mode or TCP server)
-    bool catchAllMode = Modbus::isBroadcastId(_serverId) || _interface.checkCatchAllSlaveIds();
+    bool catchAllMode = Modbus::isBroadcastId(_serverId) || sourceInterface.checkCatchAllSlaveIds();
     bool broadcastRequest = Modbus::isBroadcastId(request.slaveId);
     dropResponse = broadcastRequest;  // We don't respond to broadcast requests
     bool dropRequest = !catchAllMode 
@@ -140,7 +177,7 @@ Server::Result Server::handleRequest(const Modbus::Frame& request) {
     // Check that the function code is valid, return an exception if not
     if (!ModbusCodec::isValidFunctionCode(static_cast<uint8_t>(request.fc))) {
         _responseBuffer.exceptionCode = Modbus::ILLEGAL_FUNCTION;
-        if (!dropResponse) _interface.sendFrame(_responseBuffer, nullptr, nullptr);
+        if (!dropResponse) sourceInterface.sendFrame(_responseBuffer, nullptr, nullptr);
         return Error(Server::ERR_RCV_ILLEGAL_FUNCTION);
     }
 
@@ -153,7 +190,7 @@ Server::Result Server::handleRequest(const Modbus::Frame& request) {
 
     // Send the response (unless broadcast) - keep mutex locked during transmission
     if (!dropResponse) {
-        Server::Result res = sendResponse(_responseBuffer);
+        Server::Result res = sendResponse(_responseBuffer, sourceInterface);
         if (res != Server::SUCCESS) return res;
     }
 
@@ -456,8 +493,8 @@ Server::Result Server::handleWrite(const Modbus::Frame& request, Modbus::Frame&
     return Success();
 }
 
-Server::Result Server::sendResponse(const Modbus::Frame& response) {
-    auto sendResult = _interface.sendFrame(response, nullptr, nullptr);
+Server::Result Server::sendResponse(const Modbus::Frame& response, ModbusInterface::IInterface& targetInterface) {
+    auto sendResult = targetInterface.sendFrame(response, nullptr, nullptr);
     if (sendResult != ModbusInterface::IInterface::SUCCESS) {
         return Error(Server::ERR_RSP_TX_FAILED);
     }
diff --git a/src/apps/ModbusServer.h b/src/apps/ModbusServer.h
index e6c3ab6..2e59dcc 100644
--- a/src/apps/ModbusServer.h
+++ b/src/apps/ModbusServer.h
@@ -5,6 +5,8 @@
 
 #pragma once
 
+#include <initializer_list>
+#include <array>
 #include "core/ModbusCore.h"
 #include "core/ModbusWord.hpp"
 #include "interfaces/ModbusInterface.hpp"
@@ -14,6 +16,10 @@
     #define EZMODBUS_SERVER_MAX_WORD_SIZE 8
 #endif
 
+#ifndef EZMODBUS_SERVER_MAX_INTERFACES // Server max simultaneous interfaces
+    #define EZMODBUS_SERVER_MAX_INTERFACES 2
+#endif
+
 
 namespace Modbus {
 
@@ -25,6 +31,7 @@ public:
 
     static constexpr uint32_t MAX_REGISTERS = 65535;
     static constexpr size_t MAX_WORD_SIZE = (size_t)EZMODBUS_SERVER_MAX_WORD_SIZE; // max no. registers per word
+    static constexpr size_t MAX_INTERFACES = (size_t)EZMODBUS_SERVER_MAX_INTERFACES; // max simultaneous interfaces
 
     // ===================================================================================
     // RESULT TYPES
@@ -118,9 +125,12 @@ public:
     // CONSTRUCTOR & PUBLIC METHODS
     // ===================================================================================
 
-    // Constructor with WordStore (now mandatory)
+    // Single-interface ctor
     Server(ModbusInterface::IInterface& interface, IWordStore& store, uint8_t slaveId = 1, bool rejectUndefined = true);
-    
+
+    // Multi-interface ctor
+    Server(std::initializer_list<ModbusInterface::IInterface*> interfaces, IWordStore& store, uint8_t slaveId = 1, bool rejectUndefined = true);
+
     ~Server();
 
     Result begin();
@@ -136,12 +146,26 @@ public:
     bool isBusy();
 
 private:
+    // ===================================================================================
+    // PRIVATE TYPES
+    // ===================================================================================
+
+    // Callback context for interface routing
+    struct RcvCallbackCtx {
+        Server* server;
+        ModbusInterface::IInterface* sourceInterface;
+    };
+
     // ===================================================================================
     // PRIVATE MEMBERS
     // ===================================================================================
 
-    // Configuration
-    ModbusInterface::IInterface& _interface;
+    // Interfaces management
+    std::array<ModbusInterface::IInterface*, MAX_INTERFACES> _interfaces;
+    std::array<RcvCallbackCtx, MAX_INTERFACES> _rcvCbContexts;  // Callback contexts (must stay valid for lifetime)
+    size_t _interfaceCount = 0;
+
+    // Server configuration
     uint8_t _serverId;
     bool _rejectUndefined; // If false, undefined registers will be silently ignored (no exception returned)
     bool _isInitialized = false;
@@ -159,10 +183,10 @@ private:
     // ===================================================================================
 
     // Request handlers
-    Result handleRequest(const Modbus::Frame& request);
+    Result handleRequest(const Modbus::Frame& request, ModbusInterface::IInterface& sourceInterface);
     Result handleRead(const Modbus::Frame& request, Modbus::Frame& response);
     Result handleWrite(const Modbus::Frame& request, Modbus::Frame& response);
-    Result sendResponse(const Modbus::Frame& response);
+    Result sendResponse(const Modbus::Frame& response, ModbusInterface::IInterface& targetInterface);
 
     // Find helpers
     
-- 
2.46.0

From 26d95ac6ea07d35174cc40beb53bc5d6f243c849 Mon Sep 17 00:00:00 2001
From: Pierre Jay <p.jay@orius.co>
Date: Sun, 21 Sep 2025 17:14:32 +0200
Subject: [PATCH] Add test_multi_interface_server in test_tcp_client_loopback

---
 test/test_tcp_client_loopback/test_main.cpp | 114 ++++++++++++++++++++
 1 file changed, 114 insertions(+)

diff --git a/test/test_tcp_client_loopback/test_main.cpp b/test/test_tcp_client_loopback/test_main.cpp
index 6c216e8..ccda033 100644
--- a/test/test_tcp_client_loopback/test_main.cpp
+++ b/test/test_tcp_client_loopback/test_main.cpp
@@ -1701,6 +1701,116 @@ void test_client_reconnect_on_first_request() {
     Modbus::Logger::logln("Client successfully reconnected on first request");
 }
 
+void test_multi_interface_server() {
+    Modbus::Logger::logln("TEST_MULTI_INTERFACE_SERVER");
+    constexpr uint16_t LOCAL_PORT = MODBUS_PORT + 1;
+
+    // Static instances to avoid stack overflow
+    static ModbusHAL::TCP localTcpHal(LOCAL_PORT);  // Different port to avoid conflict
+    static ModbusHAL::UART localRtuHal(UART_NUM_1, 9600, ModbusHAL::UART::CONFIG_8N1, D5, D6);
+
+    static ModbusInterface::TCP tcpInterface(localTcpHal, Modbus::SERVER);
+    static ModbusInterface::RTU rtuInterface(localRtuHal, Modbus::SERVER);
+
+    static Modbus::StaticWordStore<20> localStore;
+
+    // Create multi-interface server with new ctor
+    static Modbus::Server multiServer({&tcpInterface, &rtuInterface}, localStore, 1);
+
+    TEST_ASSERT_EQUAL(Modbus::Server::SUCCESS, multiServer.begin());
+
+    // Add test words to the server
+    Modbus::Word testHoldingReg = {
+        .type = Modbus::HOLDING_REGISTER,
+        .startAddr = 1000,
+        .nbRegs = 1,
+        .readHandler = [](const Modbus::Word& word, uint16_t* outVals, void* userCtx) -> Modbus::ExceptionCode {
+            outVals[0] = 0x1234;  // Test value
+            return Modbus::NULL_EXCEPTION;
+        },
+        .writeHandler = [](const uint16_t* writeVals, const Modbus::Word& word, void* userCtx) -> Modbus::ExceptionCode {
+            // Accept any write for test
+            return Modbus::NULL_EXCEPTION;
+        },
+        .userCtx = nullptr
+    };
+
+    TEST_ASSERT_EQUAL(Modbus::Server::SUCCESS, multiServer.addWord(testHoldingReg));
+
+    // Test TCP client → multi-interface server
+    static ModbusHAL::TCP clientTcpHal("127.0.0.1", LOCAL_PORT);
+    static ModbusInterface::TCP clientTcp(clientTcpHal, Modbus::CLIENT);
+    static Modbus::Client tcpClient(clientTcp);
+
+    // Initialize TCP client
+    TEST_ASSERT_EQUAL(ModbusInterface::IInterface::SUCCESS, clientTcp.begin());
+
+    // Test TCP read
+    Modbus::Frame tcpRequest = {
+        .type       = Modbus::REQUEST,
+        .fc         = Modbus::READ_HOLDING_REGISTERS,
+        .slaveId    = 1,
+        .regAddress = 1000,
+        .regCount   = 1,
+        .data       = {},
+    };
+    Modbus::Frame tcpResponse;
+
+    vTaskDelay(pdMS_TO_TICKS(100)); // Let everything settle
+    auto tcpResult = tcpClient.sendRequest(tcpRequest, tcpResponse);
+
+    TEST_ASSERT_EQUAL(Modbus::Client::SUCCESS, tcpResult);
+    TEST_ASSERT_EQUAL(0x1234, tcpResponse.getRegister(0));
+
+    // Test RTU client → multi-interface server (via UART loopback)
+    static ModbusHAL::UART clientRtuHal(UART_NUM_2, 9600, ModbusHAL::UART::CONFIG_8N1, D7, D8);
+    static ModbusInterface::RTU clientRtu(clientRtuHal, Modbus::CLIENT);
+    static Modbus::Client rtuClient(clientRtu);
+
+    // Initialize RTU client
+    TEST_ASSERT_EQUAL(ModbusInterface::IInterface::SUCCESS, clientRtu.begin());
+
+    // Test RTU read
+    Modbus::Frame rtuRequest = {
+        .type       = Modbus::REQUEST,
+        .fc         = Modbus::READ_HOLDING_REGISTERS,
+        .slaveId    = 1,
+        .regAddress = 1000,
+        .regCount   = 1,
+        .data       = {},
+    };
+    Modbus::Frame rtuResponse;
+
+    vTaskDelay(pdMS_TO_TICKS(100)); // Let server initialize
+    auto rtuResult = rtuClient.sendRequest(rtuRequest, rtuResponse);
+
+    TEST_ASSERT_EQUAL(Modbus::Client::SUCCESS, rtuResult);
+    TEST_ASSERT_EQUAL(0x1234, rtuResponse.getRegister(0));
+
+    // Test concurrent access
+
+    // Send requests almost simultaneously (start by RTU -> higher delay)
+    Modbus::Frame concurrentTcpResp, concurrentRtuResp;
+    Modbus::Client::Result rtuTracker, tcpTracker = Modbus::Client::NODATA;
+    rtuClient.sendRequest(rtuRequest, concurrentRtuResp, &rtuTracker);
+    vTaskDelay(pdMS_TO_TICKS(1));
+    tcpClient.sendRequest(tcpRequest, concurrentTcpResp, &tcpTracker);
+
+    TickType_t start = xTaskGetTickCount();
+    TickType_t elapsed = 0;
+    // Wait for both requests to complete
+    do {
+        vTaskDelay(pdMS_TO_TICKS(1));
+        elapsed = xTaskGetTickCount() - start;
+    } while ((tcpTracker == Modbus::Client::NODATA || rtuTracker == Modbus::Client::NODATA) 
+            && elapsed < pdMS_TO_TICKS(1500)); // Timeout to avoid being stuck here
+
+    // First arrived (RTU) should succeed, the other one (TCP) should fail
+    TEST_ASSERT_EQUAL(Modbus::Client::SUCCESS, rtuTracker);
+    TEST_ASSERT_EQUAL(Modbus::Client::ERR_BUSY, tcpTracker);
+    TEST_ASSERT_EQUAL(0x1234, concurrentRtuResp.getRegister(0));
+}
+
 void setup() {
     // Debug port
     Serial.setTxBufferSize(2048);
@@ -1785,6 +1895,10 @@ void setup() {
     // RUN_TEST(test_concurrent_calls);
     RUN_TEST(test_server_busy_exception);
     RUN_TEST(test_client_reconnect_on_first_request);
+
+    // Multi-interface server test
+    RUN_TEST(test_multi_interface_server);
+
     UNITY_END();
 }
 
-- 
2.46.0

